Backport of:

From 7ae776fa4db933a17598875fc5917aaea531e4cf Mon Sep 17 00:00:00 2001
From:  <jnperlin@hydra.localnet>
Date: Sat, 17 Oct 2015 21:15:39 +0200
Subject: [PATCH] [Bug 2948] Potential Infinite Loop in ntpq and ntpdc

---
 ChangeLog     |  2 ++
 ntpdc/ntpdc.c | 21 ++++++++++++++++++++-
 ntpq/ntpq.c   | 24 ++++++++++++++++++++++--
 3 files changed, 44 insertions(+), 3 deletions(-)

Index: ntp-4.2.6.p3+dfsg/ntpdc/ntpdc.c
===================================================================
--- ntp-4.2.6.p3+dfsg.orig/ntpdc/ntpdc.c	2016-06-01 12:27:34.815373760 -0400
+++ ntp-4.2.6.p3+dfsg/ntpdc/ntpdc.c	2016-06-01 12:27:34.811373708 -0400
@@ -657,6 +657,10 @@
 	fd_set fds;
 	int n;
 	int pad;
+	/* absolute timeout checks. Not 'time_t' by intention! */
+	uint32_t tobase;	/* base value for timeout */
+	uint32_t tospan;	/* timeout span (max delay) */
+	uint32_t todiff;	/* current delay */
 
 	/*
 	 * This is pretty tricky.  We may get between 1 and many packets
@@ -673,12 +677,14 @@
 	lastseq = 999;	/* too big to be a sequence number */
 	memset(haveseq, 0, sizeof(haveseq));
 	FD_ZERO(&fds);
+	tobase = (uint32_t)time(NULL);
 
     again:
 	if (firstpkt)
 		tvo = tvout;
 	else
 		tvo = tvsout;
+	tospan = (uint32_t)tvo.tv_sec + (tvo.tv_usec != 0);
 	
 	FD_SET(sockfd, &fds);
 	n = select(sockfd+1, &fds, (fd_set *)0, (fd_set *)0, &tvo);
@@ -687,6 +693,17 @@
 		warning("select fails", "", "");
 		return -1;
 	}
+	
+	/*
+	 * Check if this is already too late. Trash the data and fake a
+	 * timeout if this is so.
+	 */
+	todiff = (((uint32_t)time(NULL)) - tobase) & 0x7FFFFFFFu;
+	if ((n > 0) && (todiff > tospan)) {
+		n = recv(sockfd, (char *)&rpkt, sizeof(rpkt), 0);
+		n = 0; /* faked timeout return from 'select()'*/
+	}
+	
 	if (n == 0) {
 		/*
 		 * Timed out.  Return what we have
@@ -831,8 +848,10 @@
 	}
 
 	/*
-	 * So far, so good.  Copy this data into the output array.
+	 * So far, so good.  Copy this data into the output array. Bump
+	 * the timeout base, in case we expect more data.
 	 */
+	tobase = (uint32_t)time(NULL);
 	if ((datap + datasize + (pad * items)) > (pktdata + pktdatasize)) {
 		int offset = datap - pktdata;
 		growpktdata();
Index: ntp-4.2.6.p3+dfsg/ntpq/ntpq.c
===================================================================
--- ntp-4.2.6.p3+dfsg.orig/ntpq/ntpq.c	2016-06-01 12:27:34.815373760 -0400
+++ ntp-4.2.6.p3+dfsg/ntpq/ntpq.c	2016-06-01 12:27:34.811373708 -0400
@@ -834,6 +834,10 @@
 	int len;
 	int first;
 	char *data;
+	/* absolute timeout checks. Not 'time_t' by intention! */
+	uint32_t tobase;	/* base value for timeout */
+	uint32_t tospan;	/* timeout span (max delay) */
+	uint32_t todiff;	/* current delay */
 
 	/*
 	 * This is pretty tricky.  We may get between 1 and MAXFRAG packets
@@ -850,6 +854,8 @@
 	numfrags = 0;
 	seenlastfrag = 0;
 
+	tobase = (uint32_t)time(NULL);
+	
 	FD_ZERO(&fds);
 
 	/*
@@ -862,6 +868,7 @@
 			tvo = tvout;
 		else
 			tvo = tvsout;
+		tospan = (uint32_t)tvo.tv_sec + (tvo.tv_usec != 0);
 		
 		FD_SET(sockfd, &fds);
 		n = select(sockfd + 1, &fds, NULL, NULL, &tvo);
@@ -870,6 +877,17 @@
 			warning("select fails", "", "");
 			return -1;
 		}
+
+		/*
+		 * Check if this is already too late. Trash the data and
+		 * fake a timeout if this is so.
+		 */
+		todiff = (((uint32_t)time(NULL)) - tobase) & 0x7FFFFFFFu;
+		if ((n > 0) && (todiff > tospan)) {
+			n = recv(sockfd, (char *)&rpkt, sizeof(rpkt), 0);
+			n = 0; /* faked timeout return from 'select()'*/
+		}
+		
 		if (n == 0) {
 			/*
 			 * Timed out.  Return what we have
@@ -1164,10 +1182,12 @@
 		}
 
 		/*
-		 * Copy the data into the data buffer.
+		 * Copy the data into the data buffer, and bump the
+		 * timout base in case we need more.
 		 */
 		memcpy((char *)pktdata + offset, rpkt.data, count);
-
+		tobase = (uint32_t)time(NULL);
+		
 		/*
 		 * If we've seen the last fragment, look for holes in the sequence.
 		 * If there aren't any, we're done.
